\section{Exécution précise de noyaux}\label{sec:contribs:outil}

\subsection{Motivation}

Les résultats de la section précédente montrent que l'on peut globalement évaluer le comportement d'une application.
La suite naturelle est l'observation des différents facteurs pour essayer de déterminer s'il y a des améliorations possibles pour ce comportement, et comment faire pour l'améliorer.
Au final une application basée sur des tâches avec dépendances se ramène à ordonnancer un graphe de tâches sur un ensemble de ressources.
Sachant que dans le contexte d'une machine NUMA le temps d'exécution d'une tâche dépend, entre autre, de la ressource sur laquelle elle est placée, on a envie de pouvoir modéliser le comportement individuel de chaque type de tâche en fonction de son placement et du placement des données.
Une fois cela fait, cela permettra d'identifier des potentielles variations de comportement, et ajuster les heuristiques d'ordonnancement pour prendre en compte ces variations.

C'est à ce besoin que répond NOMDEL4OUTIL : permettre à l'utilisateur de définir ce qu'il exécute et où, et garantir cette exécution, avec un certain nombre de variables observables.

\subsection{Description d'un scenario}

Un scenario est défini de la manière suivante :
\begin{itemize}
 \item Un ensemble de données et variables
 \item Une liste d'actions à effectuer
 \item Un ensemble de caractéristiques à observer
\end{itemize}

\subsubsection{Données et variables}

L'utilisateur fourni les noms et type des variables utilisées en paramètres des différents noyaux.
Ces variables peuvent être des constantes, ou être initialisées par une action dans le scénario.

Voici un exemple de déclaration de données :
\begin{lstlisting}[language=Ruby]
- a:
  - type: "double *"
- b:
  - type: "double *"
- c:
  - type: "double *"
- block_size:
  - type: "int"
  - value: 256
\end{lstlisting}

\subsubsection{Actions}

L'utilisateur indique une série d'actions à exécuter, et avec quels paramètres.
Une action peut avoir les caractéristiques suivantes :
\begin{itemize}
  \item repeat
  \item sync
  \item kernel: action name
  \item params: list of variables
  \item core: le coeur
\end{itemize}

Ces actions correspondent à des fonctions connues par l'outil, que l'utilisateur peut aisément ajouter.

Voici un exemple de déclaration d'actions, utilisant les données ci dessus :
\begin{lstlisting}[language=Ruby]
  actions: 
  - repeat: 1
    sync: false
    kernel: init_blas_bloc
    params: 
    - a
    - block_size
    core: 0
  - repeat: 1
    sync: false
    kernel: init_blas_bloc
    params: 
    - b
    - block_size
    core: 0
  - repeat: 1
    sync: false
    kernel: init_blas_bloc
    params: 
    - c
    - block_size
    core: 0
  - repeat: 50
    sync: true
    kernel: dgemm
    params: 
    - a
    - b
    - c
    - block_size
    core: 0
\end{lstlisting}

\subsubsection{Observeurs}

Exemples de caractéristiques observables :

\begin{itemize}
  \item temps passé dans l'action (ms)
  \item performance personalisé (gflops)
  \item compteurs de perf
\end{itemize}

Example de section dans le scenario :
\begin{lstlisting}[language=Ruby]
flops_dgemm:
- block_size
papi:
- PAPI_L3_TCM
- PAPI_L3_DCR
- PAPI_L3_DCW
time:
- ms
\end{lstlisting}

\subsection{Design de l'outil}

Afin de garantir un minimum de "bruit" lors des expériences, il fallait que l'archicture de l'outil soit simple, avec peu de logique relative au contrôle de l'exécution des tâches.

Le flot d'exécution est le suivant :
\begin{itemize}
 \item L'utilisateur fourni un scenario
 \item L'ensemble des coeurs utilisés est déterminé à partir du scénario
 \item Pour chaque coeur, un thread est créé et attaché à ce coeur, et une queue (FIFO) de tâches est créée
 \item L'ensemble des tâches définies dans le scenario est poussée dans les queues dans l'ordre défini
 \item Le scenario est déroulé
 \item Un résumé des caractéristiques observées est affiché
\end{itemize}

\subsection{Exemples de noyaux}

Noyaux de cholesky, dgemm à la main, mem bandwidth

\subsection{Quelles caractéristiques observer ?}
Perf ctr, perfs tout court

\subsection{Application aux noyaux de Cholesky}
\subsection{Impact de la bibliothèque BLAS}

matter for top perf, not for overall behavior

\subsection{Conclusion : modélisation de base possible}

