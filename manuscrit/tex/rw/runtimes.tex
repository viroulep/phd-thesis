\section{Compilateurs populaires et leurs supports exécutif}\label{sec:rw:runtimes}


Avant de rentrer dans le vif du sujet, il nous paraît important d'insister sur la distinction entre compilateur et support exécutif.

Tous les modèles de programmation ne sont pas implémenté par tous les compilateurs, mais par contre le fonctionnement général reste le même.
Le code source va contenir des directives (|#pragma|) ou des appels de fonctions décrits par le modèle de programmation.

Le compilateur ne va pas laisser ces éléments tels quels dans l'objet binaire générer : il va les transformer en un ensemble de fonctions élémentaires imposées par le support exécutif. Cet ensemble de fonctions élementaires s'appelle l'\emph{ABI} (pour \emph{Abstract Binary Interface}).

Pour donner un exemple concret, un code de ce type en OpenMP :
\begin{lstlisting}
void foo()
{
  // ...
  #pragma omp task
  {
    // calcul
  }
  // ...
}
\end{lstlisting}

Entrainera deux transformations importantes :
\begin{itemize}
  \item l'\emph{outlining} de la fonction, qui consiste à externaliser le code de la tâche et son contexte dans une fonction séparée.
  \item la substitution du pragma par un appel au support exécutif.
\end{itemize}

Cela donnera au final un code binaire généré correspondant à un programme de ce type :

\begin{lstlisting}
void outlined(struct Context c)
{
  // unpacking du contexte
  // calcul
}

void foo()
{
  // ...
  struct Context c;
  // capture des variables locales et partagées
  runtime_specific_create_task(outlined, c);
  // ...
}
\end{lstlisting}

La conséquence directe de cette transformation est qu'il existe un \textbf{couplage fort} entre le compilateur et le support exécutif.

Dans le cas spécifique d'OpenMP il y a principalement 3 compilateurs qui implémentent complètement (et suivent rapidement) le standard : GCC, ICC, et Clang.


\subsubsection{GCC}

Le compilateur GCC est livré avec son support exécutif par défaut : libGOMP.

libGOMP ne dispose pas de stratégie d'ordonnancement particulièrement dédiée aux architectures NUMA.
L'ordonnancement des tâches est gérée par la technique du vol de travail, avec une queue de tâche unique pour l'ensemble des threads.



\subsubsection{ICC}

ICC est livré avec son runtime, open source, libIOMP.


\subsubsection{Clang/LLVM}

Pour le support d'OpenMP, l'infrastructure Clang/LLVM embarque une version du support exécutif d'Intel, renommée libOMP.

\subsubsection{Compatibilité}

Dans un scenario idéal, on pourrait à loisir interchanger les compilateurs et supports exécutifs utilisés : par exemple compiler du code avec GCC, et l'exécuter en utilisant le support exécutif d'Intel.

Clang et ICC compilant pour le même support exécutif, eux deux sont effectivement interchangeables.

En revanche libGOMP et libIOMP/libOMP utilisent des ABIs différentes, les codes générés par GCC et Clang/ICC sont donc a priori incompatibles.
Heureusement les développeurs de libOMP ont implémentés une couche d'interconnexion entre les deux ABIs, ce qui permet effectivement d'interchanger à loisir ces 3 compilateurs populaires et leurs support exécutifs.

\section{Autres supports exécutifs}\label{sec:rw:runtimes}

\subsection{LIBKOMP/Kaapi}

À base de tâche légère, vol de travail.
Support ABI libGOMP (utilisé par GCC), et libiomp

\cite{Gautier2007}, Kaapi: A Thread Scheduling Runtime System for Data Flow Computations on Cluster of Multi-Processors


\subsection{OMPSs}

Modèle de programmation inspiré par OpenMP, à base de directives.

Un compilo (mercurium) + un runtime nanos++

\cite{OMPSs}, Ompss: a proposal for programming heterogeneous multi-core architectures

\subsection{StarPU/Kstar}

\cite{StarPU}, StarPU: A Unified Platform for Task Scheduling on Heterogeneous Multicore Architectures


Others

\subsection{Quark}
\subsection{OpenStream}

Blabla
