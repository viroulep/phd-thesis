\documentclass{Styles/llncs}
%\documentclass[12pt,letterpaper]{article}
\usepackage{times}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{url}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{verbatim}
\usepackage{parcolumns}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
%Prevents floating item to "jump" between sections
\usepackage[section]{placeins}
\usepackage{booktabs}
\newcommand{\arevoir}[1]{#1}

\newcommand{\kaapi}{\textsc{\mbox{kaapi}}\xspace}

\newcommand{\libXKOMP}{\textsc{libKOMP}\xspace}

\usepackage{xcolor}
\usepackage{todonotes}
\usepackage[color,leftbars]{changebar}

\newcommand{\cfsect}[1]{(\textit{cf.} section~\ref{#1})}
\newcommand{\cfsectpage}[1]{(\textit{cf.} section~\ref{#1}, page~\pageref{#1})}
\providecommand{\figureref}[1]{\figname~\ref{#1}}
\providecommand{\cftab}[1]{(\textit{cf.} tableau~\ref{#1})}
\newcommand{\cmd}[1]{{\upshape\texttt{\symbol{"5C}#1}}}

\newenvironment{remarque}
{\description \item[Remarque:] \ \slshape}
{\enddescription}

\makeatletter
\newbox\sf@box
\newenvironment{SubFloat}[2][]%
  {\def\sf@one{#1}%
   \def\sf@two{#2}%
   \setbox\sf@box\hbox
     \bgroup}%
  { \egroup
   \ifx\@empty\sf@two\@empty\relax
     \def\sf@two{\@empty}
   \fi
   \ifx\@empty\sf@one\@empty\relax
     \subfloat[\sf@two]{\box\sf@box}%
   \else
     \subfloat[\sf@one][\sf@two]{\box\sf@box}%
   \fi}
\makeatother
\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}
\renewcommand{\ttdefault}{pcr}
\lstset{
	tabsize=4,
%	frame=single,
	breaklines=true,
	basicstyle=\ttfamily,
	frame=tb,
	framerule=0.2pt,
%	frameround={tttt},
	showstringspaces=false,
	language=c,
%	linewidth=0.95\textwidth,
	keywordstyle=\color{black}\bfseries,
%	keywordstyle=\color{blue},
	commentstyle=\color{OliveGreen},
	stringstyle=\color{red}\itshape,
	inputencoding=utf8/latin1,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
% OMP define
emph={\#,pragma, taskwait, omp, task, depend}, emphstyle=\color{RoyalBlue}\bfseries,
emph={[2]in,inout,out,cw}, emphstyle={[2]\color{BrickRed}\bfseries},
emph={[3]tied,untied,shared}, emphstyle={[3]\color{Gray}\bfseries},
emph={[4]lu0,fwd,bdiv,bmod}, emphstyle={[4]\color{DarkGreen}\bfseries},
emph={[5]cw, affinity}, emphstyle={[5]\color{DarkViolet}\bfseries},
    %moredelim=**[is][\only<3>{\color{red}}]{@}{@},
}
\lstdefinestyle{smaller}{basicstyle=\scriptsize\ttfamily}
\lstMakeShortInline|

\newcommand{\benchs}{KASTORS }

\sloppy

\begin{document}

\title{TODO}
\author{
  Philippe Virouleau \and François Broquedis \and Thierry Gautier \and Fabrice Rastello
 \vspace*{-1ex}}
\institute{
   Inria,
   Univ. Grenoble Alpes,  CNRS, Grenoble Institute of Technology, LIG, Grenoble, France
   LIP, ENS de Lyon, France\\
   \email{firstname.lastname@inria.fr}\\
   \email{thierry.gautier@inrialpes.fr}\\
}
\date{}
\maketitle

\begin{abstract}
  \vspace*{-5ex} TODO

\smallskip
  \noindent\textbf{Keywords:}
  \emph{
    OpenMP, task dependencies, affinity, runtime systems, NUMA
  }
\end{abstract}


\section{Introduction}

OpenMP became one of the major standard to program applications on various hardware. Nowadays the standard defines features to be able to exploit all functional units into multi-cores machine with several accelerator. OpenMP becomes de facto unavoidable in the software stacks necessary for a super computer. 
 In this paper we relate our experiences to reach high performance execution of OpenMP numerical applications on NUMA machine. If the standard has made a big step in order to provide a state-of-the-art solution for expressing parallelism of dynamic applications thanks to the tasks and especially dependencies between tasks features, few support exists to express and control the affinity between tasks and data.
 
The recently added places concept in the OpenMP version 4.0 in July 2013 mainly concern the capacity to defines execution places of threads among the embedded parallel region. Using first touch allocation policy as portable solution to control memory binding, it is possible to rely on OpenMP places to control thread affinity with respect to the memory.
Nevertheless, if this solution exists it remains cumbersome with inherent shortages: It does not ensures clarity in the program between computations and memory access; Design of library remains complex due to non composable non functional properties; It does not provide robust solution when load is high unbalanced between threads of different parallel regions. 
This is while the ARB is under discussing a new \textit{affinity} clause to pass information to the runtime in order to ensure locality between tasks and some ressources. 

In this paper, we presents our proposition to let the programmer to express affinity between tasks and memory. We present our \textit{affinity} clause to express it and we show that it is syntactically close to ARB discussion. We also explain how we have let our OpenMP runtime manages such finer information in order to better execute program. This concerns the organisation of scheduling data structure as well as the scheduler algorithm. 

The contribution of this paper is:
\begin{itemize}
\item A proposition to express in OpenMP affinity between tasks and memory.
\item A runtime extension to handle such informations to reach better performance.
\item A complete integration in clang-3.8 branch.
\end{itemize}

Some preliminary experimental results demonstrates the capacity to manage finer information such as handle by affinity of task and memory. By analyzing our experimental results, we note OpenMP depend tasks based programs, with assumption that all accessed memory regions are encoded in dependencies, can be automatically scheduled with the same level of performance without adding clause to specify affinity. 

\section{Motivation: examples where we need support}

TODO

- trouver une application qui nécessite cela, typiquement une application itérative type stencil
  -> done, jacobi, on peut comparer taskdep+affinity vs taskdep vs for, affini est meilleurs
  -> dpot, si le runtime peut être malin, c'est tout aussi simple que le programmeur indique explicitement quelle dépendance est "importante"
- une clause qui permet de contrôler l’affinité tâche / donnée ou tâche / ressources est importante pour les perf
- le comité discute de cela

\section{Contributions}

2/ contribution du papier
- implémentation d’une clause affinity dans clang et modification du runtime associé
- scheduler affinity aware (europar)
- définition de stratégie de scheduling de tâches dans région parallèle pour permettre de gérer l’affinité en utilisant la politique first touch de l’OS

\section{Implem and results}

Ici on peut refaire tourner jacobi, dpotrf, dgeqrf, avec toute la couche "affinity" de clang.

TODO~\cite{kaapi}
\section{Related work}

TODO


\section*{Acknowledgments}


This work is integrated and supported by the ELCI  project, a French FSN ("Fond pour la Société Numérique")
project that associates academic and industrial partners to design and provide software environment for very high performance
computing.
  \small \bibliographystyle{Styles/iplain}
%\nocite{*}
\bibliography{Bib/paper}

\end{document}
